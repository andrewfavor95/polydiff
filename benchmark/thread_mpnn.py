#!/usr/bin/env python

""" 
Threads MPNN sequences onto PDBs generated by diffusion and outputs PDBs
containing only backbone (N, Ca, C, O) atoms.

If --use_ligand is set, the input ligand to diffusion is superimposed onto the
ligand in the diffusion design model and all atoms from the input ligand,
including hydrogens, are copied into the output.  
"""

import sys, os, argparse, glob, tqdm, pickle
import numpy as np
import torch
from icecream import ic

script_dir = os.path.dirname(os.path.realpath(__file__))+'/'
sys.path.insert(0,script_dir+'/../')
sys.path.insert(0,script_dir+'/../RF2-allatom/')
import inference.utils
import rf2aa.parsers
import rf2aa.chemical
from parsers import load_ligand_from_pdb
from rf2aa.util import kabsch


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('datadir',type=str,help='Folder of designs')
    parser.add_argument('--seqdir',type=str,help='Folder of MPNN sequences, one .fa file per design')
    parser.add_argument('--outdir',type=str,help='Folder to put threaded MPNN PDBs')
    parser.add_argument('--use_ligand',action='store_true',default=False,
        help='Whether to parse and write ligand in the PDB. Also affects default I/O paths')
    args = parser.parse_args()

    if args.seqdir is None: 
        args.seqdir = args.datadir+('/ligmpnn/seqs/' if args.use_ligand else '/mpnn/seqs/')
    if args.outdir is None: 
        args.outdir = args.datadir+('/ligmpnn/' if args.use_ligand else '/mpnn/')

    return args

def main():
    args = get_args()

    for fn in tqdm.tqdm(glob.glob(args.datadir+'/*.pdb')):
        print('processing',fn)
        name = os.path.basename(fn).replace('.pdb','')

        # load designed protein
        parsed_pdb = inference.utils.parse_pdb(fn)
        xyz_prot = torch.tensor(parsed_pdb['xyz'])
        mask_prot = torch.tensor(parsed_pdb['mask'])
        with open(args.datadir+'/'+name+'.trb','rb') as f:
            trb = pickle.load(f)
        idx_motif = trb['con_hal_idx0']
        idx_prot = torch.tensor([x[1] for x in parsed_pdb['pdb_idx']])

        L_prot, N_atoms_prot = xyz_prot.shape[:2]
        Ls = [L_prot]

        if args.use_ligand:
            lig_name = trb['config']['inference']['ligand']

            # load ligand from design
            mol_des, xyz_sm_des, mask_sm_des, msa_sm_des, bond_feats_sm_des, atom_names_des = \
                load_ligand_from_pdb(fn, lig_name = lig_name)

            # reference ligand, to get hydrogen atoms (for downstream Rosetta scoring)
            input_pdb_fn = args.datadir+'/input/'+os.path.basename(trb['config']['inference']['input_pdb'])
            mol, xyz_sm, mask_sm, msa_sm, bond_feats_sm, atom_names = \
                load_ligand_from_pdb(input_pdb_fn, lig_name = lig_name, remove_H=False)

            # superimpose reference ligand onto design ligand
            to_align_des = np.isin(np.array(atom_names_des), np.array(atom_names))
            to_align_ref = np.isin(np.array(atom_names), np.array(atom_names_des))
            rmsd, U = kabsch(xyz_sm_des[0, to_align_des], xyz_sm[0, to_align_ref]) 
            cent_des = xyz_sm_des[0, to_align_des].mean(dim=0)
            cent_ref = xyz_sm[0, to_align_ref].mean(dim=0)
            xyz_sm = (xyz_sm - cent_ref) @ U + cent_des

            L_sm = xyz_sm.shape[1]
            Ls = [L_prot, L_sm]
            idx_sm = torch.full((L_sm,), 1)

        else:
            # blank ligand features for concatenating
            xyz_sm = torch.zeros((1,0,3))
            mask_sm = torch.zeros((1,0))
            msa_sm = torch.tensor([])
            idx_sm = torch.tensor([])
            atom_names = None
            lig_name = None
            bond_feats_sm = torch.tensor([])
            
        # combine protein & ligand features
        L = sum(Ls)
        xyz = torch.zeros((L,rf2aa.chemical.NTOTAL,3))
        xyz[:L_prot, :N_atoms_prot] = xyz_prot
        xyz[L_prot:, 1] = xyz_sm[0,:]

        mask = torch.zeros((L, rf2aa.chemical.NTOTAL)).bool()
        mask[:L_prot, :4] = mask_prot[:, :4] # omit sidechain atoms
        mask[idx_motif, :14] = mask_prot[idx_motif, :14]
        mask[L_prot:, 1] = mask_sm[0]

        bond_feats = torch.zeros((L,L))
        bond_feats[:L_prot, :L_prot] = rf2aa.util.get_protein_bond_feats(L_prot)
        bond_feats[L_prot:, L_prot:] = bond_feats_sm

        idx = torch.cat([idx_prot, idx_sm+idx_prot.max()+10])

        with open(args.seqdir+name+'.fa') as f:
            lines = f.readlines()
            n_designs = int(len(lines)/2-1)
            for i in range(n_designs):
                print('writing file', args.outdir+name+f"_{i}.pdb")
                seq = lines[2*i + 3].strip() # 2nd seq is 1st design
                seq_num = torch.tensor([rf2aa.util.aa2num[rf2aa.util.aa_123[a]] for a in seq])
                pdbstr = rf2aa.util.writepdb(
                    os.path.join(args.outdir, name+f"_{i}.pdb"),
                    atoms = xyz,
                    atom_mask = mask,
                    seq = torch.cat([seq_num, msa_sm]).long(),
                    idx_pdb = idx,
                    chain_Ls = Ls,
                    bond_feats = bond_feats[None],
                    atom_names = atom_names,
                    lig_name = lig_name
                )

if __name__ == "__main__":
    main()
