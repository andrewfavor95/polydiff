#!/usr/bin/env python

""" 
Threads MPNN sequences onto PDBs generated by diffusion and outputs PDBs
containing only backbone (N, Ca, C, O) atoms.

If --use_ligand is set, the input ligand to diffusion is superimposed onto the
ligand in the diffusion design model and all atoms from the input ligand,
including hydrogens, are copied into the output.  
"""

import logging
LOGGER = logging.getLogger(__name__)
import sys, os, argparse, glob, tqdm, pickle
import numpy as np
import torch
script_dir = os.path.dirname(os.path.realpath(__file__))+'/'
sys.path.insert(0,script_dir+'/../')
sys.path.insert(0,script_dir+'/../RF2-allatom/')
import inference.utils
import rf2aa.parsers
import rf2aa.chemical
from parsers import load_ligand_from_pdb
from rf2aa.util import kabsch
import assertpy


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('datadir',type=str,help='Folder of designs')
    parser.add_argument('--seqdir',type=str,help='Folder of MPNN sequences, one .fa file per design')
    parser.add_argument('--outdir',type=str,help='Folder to put threaded MPNN PDBs')
    parser.add_argument('--use_ligand',action='store_true',default=False,
        help='Whether to parse and write ligand in the PDB. Also affects default I/O paths')
    args = parser.parse_args()

    return args

aa_123 = {val:key for key,val in rf2aa.chemical.aa_321.items()}

def main():
    args = get_args()

    for fn in tqdm.tqdm(glob.glob(args.datadir+'/*.pdb')):
        print('processing',fn)
        name = os.path.basename(fn).replace('.pdb','')

        # load designed protein
        parsed_pdb = inference.utils.parse_pdb(fn)
        xyz_prot = torch.tensor(parsed_pdb['xyz'])
        mask_prot = torch.tensor(parsed_pdb['mask'])
        with open(args.datadir+'/'+name+'.trb','rb') as f:
            trb = pickle.load(f)
        idx_motif = trb['con_hal_idx0']
        idx_prot = torch.tensor([x[1] for x in parsed_pdb['pdb_idx']])

        L_prot, N_atoms_prot = xyz_prot.shape[:2]
        Ls = [L_prot]

        lig_name = trb['config']['inference']['ligand']
        mpnn_flavor = 'ligmpnn' if args.use_ligand and lig_name else 'mpnn'
        seqdir = args.seqdir or args.datadir+(f'/{mpnn_flavor}/seqs/')
        outdir = args.outdir or args.datadir+(f'/{mpnn_flavor}/')
        if args.use_ligand and lig_name:
            # load ligand from design
            mol_des, xyz_sm_des, mask_sm_des, msa_sm_des, bond_feats_sm_des, atom_names_des = \
                load_ligand_from_pdb(fn, lig_name = lig_name)

            # reference ligand, to get hydrogen atoms (for downstream Rosetta scoring)
            input_pdb_fn = args.datadir+'/input/'+os.path.basename(trb['config']['inference']['input_pdb'])
            mol, xyz_sm, mask_sm, msa_sm, bond_feats_sm, atom_names = \
                load_ligand_from_pdb(input_pdb_fn, lig_name = lig_name, remove_H=False)

            assertpy.assert_that(atom_names).does_not_contain_duplicates()
            assertpy.assert_that(atom_names_des).does_not_contain_duplicates()

            # superimpose reference ligand onto design ligand
            atom_names = [a.strip() for a in atom_names]
            atom_names_des = [a.strip() for a in atom_names_des]
            to_align_des = np.isin(np.array(atom_names_des), np.array(atom_names))
            to_align_ref = np.isin(np.array(atom_names), np.array(atom_names_des))
            sm_des = xyz_sm_des[0, to_align_des]
            sm_ref = xyz_sm[0, to_align_ref]
            rmsd, U = kabsch(xyz_sm_des[0, to_align_des], xyz_sm[0, to_align_ref]) 
            cent_des = xyz_sm_des[0, to_align_des].mean(dim=0)
            cent_ref = xyz_sm[0, to_align_ref].mean(dim=0)
            xyz_sm = (xyz_sm - cent_ref) @ U + cent_des

            L_sm = xyz_sm.shape[1]
            Ls = [L_prot, L_sm]
            idx_sm = torch.full((L_sm,), 1)

        else:
            # blank ligand features for concatenating
            xyz_sm = torch.zeros((1,0,3))
            mask_sm = torch.zeros((1,0))
            msa_sm = torch.tensor([])
            idx_sm = torch.tensor([])
            atom_names = None
            lig_name = None
            bond_feats_sm = torch.tensor([])
            
        # combine protein & ligand features
        L = sum(Ls)
        xyz = torch.zeros((L,rf2aa.chemical.NTOTAL,3))
        xyz[:L_prot, :N_atoms_prot] = xyz_prot
        xyz[L_prot:, 1] = xyz_sm[0,:]

        mask = torch.zeros((L, rf2aa.chemical.NTOTAL)).bool()
        mask[:L_prot, :4] = mask_prot[:, :4] # omit sidechain atoms
        mask[idx_motif, :14] = mask_prot[idx_motif, :14]
        mask[L_prot:, 1] = mask_sm[0]

        bond_feats = torch.zeros((L,L))
        bond_feats[:L_prot, :L_prot] = rf2aa.util.get_protein_bond_feats(L_prot)
        bond_feats[L_prot:, L_prot:] = bond_feats_sm

        idx = torch.cat([idx_prot, idx_sm+idx_prot.max()+10])

        with open(seqdir+name+'.fa') as f:
            lines = f.readlines()
            n_designs = int(len(lines)/2-1)
            if n_designs == -1:
                LOGGER.debug(seqdir+name+'.fa')
            for i in range(n_designs):
                print('writing file', outdir+name+f"_{i}.pdb")
                seq = lines[2*i + 3].strip() # 2nd seq is 1st design
                seq_num = torch.tensor([rf2aa.util.aa2num[aa_123[a]] for a in seq])
                pdbstr = rf2aa.util.writepdb(
                    os.path.join(outdir, name+f"_{i}.pdb"),
                    atoms = xyz,
                    atom_mask = mask,
                    seq = torch.cat([seq_num, msa_sm]).long(),
                    idx_pdb = idx,
                    chain_Ls = Ls,
                    bond_feats = bond_feats[None],
                    atom_names = atom_names,
                    lig_name = lig_name
                )

if __name__ == "__main__":
    main()